import { Client, Room } from "colyseus";
import { MESSAGE, InputPayload, NamePayload, StartMatchPayload } from "../messages";
import { DriftState, Player } from "../schema/State";

const SIMULATION_RATE = 1000 / 30; // 30 ticks por segundo
const BASE_SPEED = 19; // unidades por segundo (alinhado com cliente)
const YAW_ACCELERATION = 2.8; // variação de yaw quando drifting (mais responsivo)
const YAW_RECOVERY = 5.5; // fator de recuperação quando não driftando (mais rápido)
const TRACK_HALF_WIDTH = 5.8; // largura da pista
const MATCH_CAPACITY = 5;
const MIN_PLAYERS_PRIVATE = 2; // mínimo para partidas privadas
const MIN_PLAYERS_PUBLIC = 5; // mínimo para partidas públicas (sala cheia)
const MATCH_DURATION_MS = 120_000;
const COUNTDOWN_SECONDS = 5;
const PUBLIC_BETS = [2, 5, 25];
const PLATFORM_FEE_RATE = 0.10;

interface DriftRoomOptions {
  queueType?: "public" | "private";
  betAmount?: number;
  inviteCode?: string;
  host?: boolean;
  platformUserId?: string;
  displayName?: string;
}

export class DriftRoom extends Room<DriftState> {
  private countdownTimer?: NodeJS.Timeout;
  private countdownRemaining = 0;
  private matchStartTimestamp = 0;
  private matchTimeout?: NodeJS.Timeout;
  private hostSessionId?: string;
  private queueType: "public" | "private" = "public";

  onCreate(options: DriftRoomOptions = {}): void {
    this.maxClients = MATCH_CAPACITY;
    this.setPatchRate(1000 / 18);
    this.queueType = options.queueType === "private" ? "private" : "public";

    const betAmount = this.resolveBetAmount(options.betAmount);
    const inviteCode = this.queueType === "private"
      ? this.normalizeInvite(options.inviteCode) ?? this.generateInviteCode()
      : "";

    const state = new DriftState();
    state.betAmount = betAmount;
    state.prizePool = 0;
    state.roomType = this.queueType;
    state.inviteCode = inviteCode;
    state.status = "waiting";
    state.countdown = 0;
    state.playerCount = 0;
    state.hostId = "";
    this.setState(state);

    this.setSimulationInterval((deltaTime) => this.updatePlayers(deltaTime), SIMULATION_RATE);
    this.refreshEconomicState();
    this.updateMetadata();

    this.onMessage(MESSAGE.INPUT, (client, payload) => this.handleInput(client, payload));
    this.onMessage(MESSAGE.NAME, (client, payload) => this.handleName(client, payload));
    this.onMessage(MESSAGE.START_MATCH, (client, payload) => this.handleStartMatch(client, payload));
  }

  onAuth(_client: Client, options: DriftRoomOptions = {}): boolean {
    const queueType = options.queueType === "private" ? "private" : "public";
    console.debug('[drift-room] onAuth', {
      queueType,
      expectedQueue: this.queueType,
      hostSessionId: this.hostSessionId,
      roomInvite: this.state.inviteCode,
      incomingInvite: options.inviteCode,
      betAmount: options.betAmount,
      hostFlag: options.host
    });
    if (queueType !== this.queueType) {
      return false;
    }

    if (this.queueType === "public") {
      return this.resolveBetAmount(options.betAmount) === this.state.betAmount;
    }

    if (!this.hostSessionId && options.host) {
      return true;
    }

    const invite = this.normalizeInvite(options.inviteCode);
    return invite !== undefined && invite === this.state.inviteCode;
  }

  onJoin(client: Client, options: DriftRoomOptions = {}): void {
    console.debug('[drift-room] onJoin', {
      sessionId: client.sessionId,
      existingPlayers: this.clients.length,
      options
    });
    const player = new Player();
    player.id = client.sessionId;
    const trimmedName = options.displayName?.toString().trim();
    player.name = trimmedName && trimmedName.length > 0
      ? trimmedName.slice(0, 20)
      : `Driver-${client.sessionId.substring(0, 4)}`;
    player.opacity = 1;
    player.betAmount = this.state.betAmount;
    player.platformId = options.platformUserId ?? "";
    this.state.players.set(client.sessionId, player);

    console.log('[drift-room] Player added to MapSchema:', {
      sessionId: client.sessionId,
      name: player.name,
      totalPlayers: this.state.players.size,
      playerIds: Array.from(this.state.players.keys()),
      queueType: this.queueType
    });

    if (this.queueType === "private" && !this.hostSessionId) {
      this.hostSessionId = client.sessionId;
      this.state.hostId = client.sessionId;
    }

    this.state.playerCount = this.clients.length;
    this.refreshEconomicState();
    client.send("seed", { seed: this.state.seed });

    this.emitLobbyInfo();
    this.emitLobbyInfo(client);
    this.updateMetadata();
    this.scheduleStartIfReady();
  }

  onLeave(client: Client): void {
    console.debug('[drift-room] onLeave', {
      sessionId: client.sessionId,
      wasHost: this.hostSessionId === client.sessionId
    });
    const player = this.state.players.get(client.sessionId);
    if (player) {
      player.eliminated = true;
      player.opacity = 0.25;
    }
    this.state.players.delete(client.sessionId);

    if (this.queueType === "private" && this.hostSessionId === client.sessionId) {
      this.hostSessionId = this.clients[0]?.sessionId;
      this.state.hostId = this.hostSessionId ?? "";
    }

    this.state.playerCount = this.clients.length;
    this.refreshEconomicState();
    this.emitLobbyInfo();
    this.updateMetadata();

    // Cancelar countdown se não há jogadores suficientes para o tipo de sala
    if (this.state.status === "countdown") {
      const minPlayers = this.queueType === "private" ? MIN_PLAYERS_PRIVATE : MIN_PLAYERS_PUBLIC;
      if (this.clients.length < minPlayers) {
        console.debug('[drift-room] Canceling countdown - not enough players', {
          current: this.clients.length,
          required: minPlayers,
          queueType: this.queueType
        });
        this.clearCountdown();
        this.state.status = "waiting";
        this.state.countdown = 0;
        this.updateMetadata();
      }
    }

    if (this.state.status === "active") {
      this.checkForWinner();
    }
  }

  onDispose(): void {
    this.clearCountdown();
    if (this.matchTimeout) {
      clearTimeout(this.matchTimeout);
      this.matchTimeout = undefined;
    }
  }

  private handleInput(client: Client, payload: InputPayload) {
    const player = this.state.players.get(client.sessionId);
    if (!player || this.state.status !== "active") {
      return;
    }

    player.pressing = Boolean(payload?.pressing);
    const steering = typeof payload?.steering === "number" ? payload.steering : 0;
    player.steering = Math.max(-1, Math.min(1, steering));
    const intensity = typeof payload?.intensity === "number" ? payload.intensity : Math.abs(player.steering);
    player.steeringIntensity = Math.max(0, Math.min(1, intensity));
  }

  private handleName(client: Client, payload: NamePayload) {
    const player = this.state.players.get(client.sessionId);
    if (!player) {
      return;
    }
    const trimmed = payload?.name?.toString().trim();
    if (trimmed) {
      player.name = trimmed.slice(0, 16);
    }
  }

  private handleStartMatch(client: Client, _payload: StartMatchPayload) {
    if (this.state.status === "active" || this.state.status === "countdown") {
      return;
    }

    const isHost = client.sessionId === this.hostSessionId;
    console.debug('[drift-room] handleStartMatch', {
      requester: client.sessionId,
      isHost,
      playerCount: this.clients.length,
      status: this.state.status
    });
    if (this.queueType === "private" && isHost) {
      if (this.clients.length >= MIN_PLAYERS_PRIVATE) {
        this.startCountdown(5);
      } else {
        console.debug('[drift-room] Cannot start - not enough players', {
          current: this.clients.length,
          required: MIN_PLAYERS_PRIVATE
        });
      }
      return;
    }
  }

  private scheduleStartIfReady() {
    if (this.state.status !== "waiting") {
      return;
    }

    if (this.queueType === "public" && this.clients.length === MATCH_CAPACITY) {
      this.startCountdown(COUNTDOWN_SECONDS);
      return;
    }

    if (this.queueType === "private" && this.clients.length === MATCH_CAPACITY) {
      this.startCountdown(3);
    }
  }

  private startCountdown(seconds: number) {
    this.clearCountdown();
    this.state.status = "countdown";
    this.countdownRemaining = seconds;
    this.state.countdown = seconds;
    this.emitLobbyInfo();
    this.updateMetadata();

    this.countdownTimer = setInterval(() => {
      this.countdownRemaining -= 1;
      this.state.countdown = Math.max(0, this.countdownRemaining);

      if (this.countdownRemaining <= 0) {
        this.clearCountdown();
        this.startMatch();
      }
    }, 1000);
  }

  private clearCountdown() {
    if (this.countdownTimer) {
      clearInterval(this.countdownTimer);
      this.countdownTimer = undefined;
    }
  }

  private startMatch() {
    if (this.state.status === "active") {
      return;
    }

    // Validar se há jogadores suficientes para iniciar
    const minPlayers = this.queueType === "private" ? MIN_PLAYERS_PRIVATE : MIN_PLAYERS_PUBLIC;
    if (this.clients.length < minPlayers) {
      console.warn('[drift-room] Cannot start match - not enough players', {
        current: this.clients.length,
        required: minPlayers,
        queueType: this.queueType
      });
      this.clearCountdown();
      this.state.status = "waiting";
      this.state.countdown = 0;
      this.updateMetadata();
      return;
    }

    console.debug('[drift-room] startMatch', {
      playerIds: Array.from(this.state.players.keys()),
      clientCount: this.clients.length
    });

    this.clearCountdown();
    this.matchStartTimestamp = Date.now();
    this.state.status = "active";
    this.state.countdown = 0;
    this.state.seed = Date.now();
    this.state.winnerId = "";
    this.state.prizePool = this.computePrizePool(true);
    this.lock();
    this.emitLobbyInfo();

    const activePlayers = Array.from(this.state.players.values());
    const spacing = 1.4;
    activePlayers.forEach((player, index) => {
      this.resetPlayer(player, true);
      const offset = (index - (activePlayers.length - 1) / 2) * spacing;
      player.z = offset;
    });

    if (this.matchTimeout) {
      clearTimeout(this.matchTimeout);
    }
    this.matchTimeout = setTimeout(() => this.finishMatch(), MATCH_DURATION_MS);

    this.updateMetadata();
  }

  private finishMatch(winner?: Player) {
    if (this.state.status !== "active") {
      return;
    }

    const resolvedWinner = winner ?? this.evaluateWinner();
    console.debug('[drift-room] finishMatch', {
      winner: resolvedWinner?.id,
      playerCount: this.clients.length
    });
    if (resolvedWinner) {
      resolvedWinner.isWinner = true;
      resolvedWinner.opacity = 1;
      this.state.winnerId = resolvedWinner.id;
    } else {
      this.state.winnerId = "";
    }

    this.state.status = "finished";
    this.matchStartTimestamp = 0;
    if (this.matchTimeout) {
      clearTimeout(this.matchTimeout);
      this.matchTimeout = undefined;
    }

    setTimeout(() => {
      this.resetForNextLobby();
    }, 8000);

    this.emitLobbyInfo();
    this.updateMetadata();
  }

  private resetForNextLobby() {
    console.debug('[drift-room] resetForNextLobby');
    this.unlock();
    this.state.status = "waiting";
    this.state.winnerId = "";
    this.state.countdown = 0;
    this.state.seed = Date.now();
    this.matchStartTimestamp = 0;

    this.state.players.forEach((player) => {
      this.resetPlayer(player, false);
    });

    this.state.playerCount = this.clients.length;
    this.refreshEconomicState();
    this.emitLobbyInfo();
    this.updateMetadata();
  }

  private checkForWinner() {
    if (this.state.status !== "active") {
      return;
    }

    const activePlayers = Array.from(this.state.players.values()).filter((player) => !player.eliminated);
    if (activePlayers.length <= 1) {
      console.debug('[drift-room] Finishing match - only one player remaining', {
        activePlayers: activePlayers.length,
        totalPlayers: this.state.players.size,
        winnerId: activePlayers[0]?.id
      });
      this.finishMatch(activePlayers[0]);
    }
  }

  private refreshEconomicState() {
    this.state.prizePool = this.computePrizePool(false);
  }

  private computePrizePool(isMatchStarting: boolean): number {
    const betAmount = this.state.betAmount;

    if (this.queueType === "private") {
      const participantCount = isMatchStarting ? this.clients.length : this.state.playerCount;
      if (participantCount <= 1) {
        return 0;
      }
      const grossPool = betAmount * Math.max(participantCount, 0);
      const netPool = grossPool * (1 - PLATFORM_FEE_RATE);
      return Math.max(0, Math.round(netPool * 100) / 100);
    }

    return betAmount * 4;
  }

  private emitLobbyInfo(target?: Client) {
    const payload = {
      roomType: this.queueType,
      inviteCode: this.queueType === "private" ? this.state.inviteCode : "",
      hostId: this.hostSessionId ?? "",
      betAmount: this.state.betAmount,
      prizePool: this.state.prizePool,
      playerCount: this.state.playerCount,
      status: this.state.status
    };

    console.debug('[drift-room] emitLobbyInfo', payload, { target: Boolean(target) });

    if (target) {
      target.send(MESSAGE.LOBBY_INFO, payload);
      return;
    }

    this.broadcast(MESSAGE.LOBBY_INFO, payload);
  }

  private updatePlayers(deltaTime: number): void {
    if (this.state.status !== "active") {
      return;
    }

    const dt = deltaTime / 1000;
    this.state.players.forEach((player) => {
      if (player.eliminated) {
        return;
      }

      const steering = player.steering;
      const intensity = Math.max(0.35, player.steeringIntensity || Math.abs(steering));
      const isDrifting = player.pressing || Math.abs(steering) > 0.05;

      // Sistema de física melhorado e mais responsivo
      if (Math.abs(steering) > 0.05) {
        // Curva ativa com steering - mais responsiva
        const turnRate = YAW_ACCELERATION * intensity * Math.sign(steering) * dt;
        player.yaw += turnRate;
      } else if (player.pressing) {
        // Drift automático quando apenas pressionando (sem steering específico)
        player.yaw += YAW_ACCELERATION * 0.45 * dt;
      } else {
        // Recuperação suave quando não está driftando
        const recovery = player.yaw * Math.min(1, YAW_RECOVERY * dt);
        player.yaw -= recovery;
      }

      // Normalizar ângulo para evitar valores extremos
      while (player.yaw > Math.PI) player.yaw -= Math.PI * 2;
      while (player.yaw < -Math.PI) player.yaw += Math.PI * 2;

      // Movimento consistente
      const forward = BASE_SPEED * dt;
      const yaw = player.yaw;

      // Usar sin para x e cos para z (coordenadas corretas)
      player.x += Math.sin(yaw) * forward;
      player.z += Math.cos(yaw) * forward;
      player.distance += forward;
      player.timeAlive += dt;

      // Verificar limites da pista
      if (Math.abs(player.z) > TRACK_HALF_WIDTH) {
        player.eliminated = true;
        player.pressing = false;
        player.opacity = 0.2;
        this.checkForWinner();
      }
    });

    // Verificar timeout da partida
    if (this.matchStartTimestamp > 0) {
      const elapsed = Date.now() - this.matchStartTimestamp;
      if (elapsed >= MATCH_DURATION_MS) {
        this.finishMatch();
      }
    }
  }

  private resetPlayer(player: Player, asActive: boolean) {
    player.x = 0;
    player.y = 1.0; // Altura adequada acima da pista
    player.z = 0;
    player.yaw = 0;
    player.distance = 0;
    player.pressing = false;
    player.steering = 0;
    player.steeringIntensity = 0;
    player.timeAlive = 0;
    player.eliminated = false;
    player.isWinner = false;
    player.opacity = asActive ? 1 : 0.5;
  }

  private evaluateWinner(): Player | undefined {
    let winner: Player | undefined;
    let bestScore = -Infinity;

    this.state.players.forEach((player) => {
      const score = player.timeAlive * 100 + player.distance;
      if (score > bestScore) {
        bestScore = score;
        winner = player;
      }
    });

    return winner;
  }

  private resolveBetAmount(betAmount?: number): number {
    if (this.queueType === "public") {
      const resolved = PUBLIC_BETS.includes(Number(betAmount)) ? Number(betAmount) : PUBLIC_BETS[0];
      return resolved;
    }
    const parsed = Number(betAmount);
    if (!Number.isFinite(parsed) || parsed <= 0) {
      return 10;
    }
    return Math.min(1_000, Math.max(1, Math.round(parsed)));
  }

  private normalizeInvite(inviteCode?: string) {
    if (typeof inviteCode !== "string") {
      return undefined;
    }
    const cleaned = inviteCode.trim().toUpperCase();
    return cleaned.length >= 4 ? cleaned : undefined;
  }

  private generateInviteCode(): string {
    // Use cryptographically secure random instead of Math.random()
    const crypto = require('crypto');
    return crypto.randomBytes(3).toString('hex').toUpperCase().slice(0, 6);
  }

  private updateMetadata() {
    this.setMetadata({
      roomType: this.state.roomType,
      betAmount: this.state.betAmount,
      inviteCode: this.queueType === "private" ? this.state.inviteCode : undefined,
      status: this.state.status,
      players: this.clients.length,
      capacity: this.maxClients,
      locked: this.locked,
      hostId: this.state.hostId
    });
  }
}
